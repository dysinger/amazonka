<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.AWS.DynamoDB.Scan</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Network-AWS-DynamoDB-Scan.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">amazonka-dynamodb-0.0.1: Amazon DynamoDB SDK.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.AWS.DynamoDB.Scan</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Request</a><ul><li><a href="#g:2">Request constructor</a></li><li><a href="#g:3">Request lenses</a></li></ul></li><li><a href="#g:4">Response</a><ul><li><a href="#g:5">Response constructor</a></li><li><a href="#g:6">Response lenses</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The Scan operation returns one or more items and item attributes by
 accessing every item in the table. To have DynamoDB return fewer items, you
 can provide a ScanFilter operation. If the total number of scanned items
 exceeds the maximum data set size limit of 1 MB, the scan stops and results
 are returned to the user as a LastEvaluatedKey value to continue the scan
 in a subsequent operation. The results also include the number of items
 exceeding the limit. A scan can result in no table data meeting the filter
 criteria. The result set is eventually consistent. By default, Scan
 operations proceed sequentially; however, for faster performance on large
 tables, applications can request a parallel Scan operation by specifying
 the Segment and TotalSegments parameters. For more information, see
 Parallel Scan in the Amazon DynamoDB Developer Guide.</p><p><a href="http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Scan.html">http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Scan.html</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Scan">Scan</a></li><li class="src short"><a href="#v:scan">scan</a> :: <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> -&gt; <a href="../amazonka-core/Network-AWS-Prelude.html#t:NonEmpty">NonEmpty</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> -&gt; <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></li><li class="src short"><a href="#v:sAttributesToGet">sAttributesToGet</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:NonEmpty">NonEmpty</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</li><li class="src short"><a href="#v:sConditionalOperator">sConditionalOperator</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ConditionalOperator">ConditionalOperator</a>)</li><li class="src short"><a href="#v:sExclusiveStartKey">sExclusiveStartKey</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</li><li class="src short"><a href="#v:sExpressionAttributeNames">sExpressionAttributeNames</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</li><li class="src short"><a href="#v:sExpressionAttributeValues">sExpressionAttributeValues</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</li><li class="src short"><a href="#v:sFilterExpression">sFilterExpression</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</li><li class="src short"><a href="#v:sLimit">sLimit</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</li><li class="src short"><a href="#v:sProjectionExpression">sProjectionExpression</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</li><li class="src short"><a href="#v:sReturnConsumedCapacity">sReturnConsumedCapacity</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ReturnConsumedCapacity">ReturnConsumedCapacity</a>)</li><li class="src short"><a href="#v:sScanFilter">sScanFilter</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:Condition">Condition</a>)</li><li class="src short"><a href="#v:sSegment">sSegment</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</li><li class="src short"><a href="#v:sSelect">sSelect</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:Select">Select</a>)</li><li class="src short"><a href="#v:sTableName">sTableName</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></li><li class="src short"><a href="#v:sTotalSegments">sTotalSegments</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:ScanResponse">ScanResponse</a></li><li class="src short"><a href="#v:scanResponse">scanResponse</a> :: <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></li><li class="src short"><a href="#v:srConsumedCapacity">srConsumedCapacity</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ConsumedCapacity">ConsumedCapacity</a>)</li><li class="src short"><a href="#v:srCount">srCount</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:srItems">srItems</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> [<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>]</li><li class="src short"><a href="#v:srLastEvaluatedKey">srLastEvaluatedKey</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</li><li class="src short"><a href="#v:srScannedCount">srScannedCount</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a>)</li></ul></div><div id="interface"><h1 id="g:1">Request</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Scan" class="def">Scan</a></p><div class="subs instances"><p id="control.i:Scan" class="caption collapser" onclick="toggleSection('i:Scan')">Instances</p><div id="section.i:Scan" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Types.html#t:AWSRequest">AWSRequest</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Types.html#t:AWSPager">AWSPager</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Data.html#t:ToQuery">ToQuery</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Data.html#t:ToHeaders">ToHeaders</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Data.html#t:ToJSON">ToJSON</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Data.html#t:ToPath">ToPath</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="../amazonka-core/Network-AWS-Types.html#t:Rs">Rs</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> = <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="../amazonka-core/Network-AWS-Types.html#t:Sv">Sv</a> <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> = <a href="Network-AWS-DynamoDB-Types.html#t:DynamoDB">DynamoDB</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:2">Request constructor</h2><div class="top"><p class="src"><a name="v:scan" class="def">scan</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></td><td class="doc"><p><code><a href="Network-AWS-DynamoDB-Scan.html#v:sTableName">sTableName</a></code></p></td></tr><tr><td class="src">-&gt; <a href="../amazonka-core/Network-AWS-Prelude.html#t:NonEmpty">NonEmpty</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></td><td class="doc"><p><code><a href="Network-AWS-DynamoDB-Scan.html#v:sAttributesToGet">sAttributesToGet</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sAttributesToGet">sAttributesToGet</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:NonEmpty">NonEmpty</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sConditionalOperator">sConditionalOperator</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:ConditionalOperator">ConditionalOperator</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sExclusiveStartKey">sExclusiveStartKey</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sExpressionAttributeNames">sExpressionAttributeNames</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sExpressionAttributeValues">sExpressionAttributeValues</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sFilterExpression">sFilterExpression</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sLimit">sLimit</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sProjectionExpression">sProjectionExpression</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sReturnConsumedCapacity">sReturnConsumedCapacity</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:ReturnConsumedCapacity">ReturnConsumedCapacity</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sScanFilter">sScanFilter</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:Condition">Condition</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sSegment">sSegment</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sSelect">sSelect</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:Select">Select</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sTableName">sTableName</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:sTotalSegments">sTotalSegments</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a></code></li></ul></div></div><h2 id="g:3">Request lenses</h2><div class="top"><p class="src"><a name="v:sAttributesToGet" class="def">sAttributesToGet</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:NonEmpty">NonEmpty</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</p><div class="doc"><p>There is a newer parameter available. Use ProjectionExpression instead.
 Note that if you use AttributesToGet and ProjectionExpression at the same
 time, DynamoDB will return a ValidationException exception. This
 parameter allows you to retrieve lists or maps; however, it cannot
 retrieve individual list or map elements. The names of one or more
 attributes to retrieve. If no attribute names are specified, then all
 attributes will be returned. If any of the requested attributes are not
 found, they will not appear in the result. Note that AttributesToGet has
 no effect on provisioned throughput consumption. DynamoDB determines
 capacity units consumed based on item size, not on the amount of data
 that is returned to an application.</p></div></div><div class="top"><p class="src"><a name="v:sConditionalOperator" class="def">sConditionalOperator</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ConditionalOperator">ConditionalOperator</a>)</p><div class="doc"><p>There is a newer parameter available. Use ConditionExpression instead.
 Note that if you use ConditionalOperator and ConditionExpression at the
 same time, DynamoDB will return a ValidationException exception. This
 parameter does not support lists or maps. A logical operator to apply to
 the conditions in the ScanFilter map: AND - If all of the conditions
 evaluate to true, then the entire map evaluates to true. OR - If at least
 one of the conditions evaluate to true, then the entire map evaluates to
 true. If you omit ConditionalOperator, then AND is the default. The
 operation will succeed only if the entire map evaluates to true.</p></div></div><div class="top"><p class="src"><a name="v:sExclusiveStartKey" class="def">sExclusiveStartKey</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</p><div class="doc"><p>The primary key of the first item that this operation will evaluate. Use
 the value that was returned for LastEvaluatedKey in the previous
 operation. The data type for ExclusiveStartKey must be String, Number or
 Binary. No set data types are allowed. In a parallel scan, a Scan request
 that includes ExclusiveStartKey must specify the same segment whose
 previous Scan returned the corresponding value of LastEvaluatedKey.</p></div></div><div class="top"><p class="src"><a name="v:sExpressionAttributeNames" class="def">sExpressionAttributeNames</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</p><div class="doc"><p>One or more substitution tokens for simplifying complex expressions. The
 following are some use cases for an ExpressionAttributeNames value: To
 shorten an attribute name that is very long or unwieldy in an expression.
 To create a placeholder for repeating occurrences of an attribute name in
 an expression. To prevent special characters in an attribute name from
 being misinterpreted in an expression. Use the # character in an
 expression to dereference an attribute name. For example, consider the
 following expression: order.customerInfo.LastName = <a href="Smith.html">Smith</a> OR
 order.customerInfo.LastName = <a href="Jones.html">Jones</a> Now suppose that you specified the
 following for ExpressionAttributeNames:
 {&quot;n&quot;:&quot;order.customerInfo.LastName&quot;} The expression can now be simplified
 as follows: <a name="n = &quot;Smith&quot; OR "></a>n = <a href="Jones.html">Jones</a>.</p></div></div><div class="top"><p class="src"><a name="v:sExpressionAttributeValues" class="def">sExpressionAttributeValues</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</p><div class="doc"><p>One or more values that can be substituted in an expression. Use the :
 character in an expression to dereference an attribute value. For
 example, consider the following expression: ProductStatus IN
 (<a href="Available.html">Available</a>,<a href="Backordered.html">Backordered</a>,<a href="Discontinued.html">Discontinued</a>) Now suppose that you specified
 the following for ExpressionAttributeValues: { &quot;a&quot;:{<a href="S.html">S</a>:<a href="Available.html">Available</a>},
 &quot;b&quot;:{<a href="S.html">S</a>:<a href="Backordered.html">Backordered</a>}, &quot;d&quot;:{<a href="S.html">S</a>:<a href="Discontinued.html">Discontinued</a>} } The expression can
 now be simplified as follows: ProductStatus IN (:a,:b,:c).</p></div></div><div class="top"><p class="src"><a name="v:sFilterExpression" class="def">sFilterExpression</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</p><div class="doc"><p>A condition that evaluates the scan results and returns only the desired
 values. The condition you specify is applied to the items scanned; any
 items that do not match the expression are not returned.</p></div></div><div class="top"><p class="src"><a name="v:sLimit" class="def">sLimit</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</p><div class="doc"><p>The maximum number of items to evaluate (not necessarily the number of
 matching items). If DynamoDB processes the number of items up to the
 limit while processing the results, it stops the operation and returns
 the matching values up to that point, and a key in LastEvaluatedKey to
 apply in a subsequent operation, so that you can pick up where you left
 off. Also, if the processed data set size exceeds 1 MB before DynamoDB
 reaches this limit, it stops the operation and returns the matching
 values up to the limit, and a key in LastEvaluatedKey to apply in a
 subsequent operation to continue the operation. For more information, see
 Query and Scan in the Amazon DynamoDB Developer Guide.</p></div></div><div class="top"><p class="src"><a name="v:sProjectionExpression" class="def">sProjectionExpression</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a>)</p><div class="doc"><p>One or more attributes to retrieve from the table. These attributes can
 include scalars, sets, or elements of a JSON document. The attributes in
 the expression must be separated by commas. If no attribute names are
 specified, then all attributes will be returned. If any of the requested
 attributes are not found, they will not appear in the result.</p></div></div><div class="top"><p class="src"><a name="v:sReturnConsumedCapacity" class="def">sReturnConsumedCapacity</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ReturnConsumedCapacity">ReturnConsumedCapacity</a>)</p></div><div class="top"><p class="src"><a name="v:sScanFilter" class="def">sScanFilter</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:Condition">Condition</a>)</p><div class="doc"><p>There is a newer parameter available. Use FilterExpression instead. Note
 that if you use ScanFilter and FilterExpression at the same time,
 DynamoDB will return a ValidationException exception. This parameter does
 not support lists or maps. A condition that evaluates the scan results
 and returns only the desired values. If you specify more than one
 condition in the ScanFilter map, then by default all of the conditions
 must evaluate to true. In other words, the conditions are ANDed together.
 (You can use the ConditionalOperator parameter to OR the conditions
 instead. If you do this, then at least one of the conditions must
 evaluate to true, rather than all of them.) Each ScanFilter element
 consists of an attribute name to compare, along with the following:
 AttributeValueList - One or more values to evaluate against the supplied
 attribute. The number of values in the list depends on the operator
 specified in ComparisonOperator . For type Number, value comparisons are
 numeric. String value comparisons for greater than, equals, or less than
 are based on ASCII character code values. For example, a is greater than
 A, and aa is greater than B. For a list of code values, see
 http:/<em>en.wikipedia.org</em>wiki/ASCII#ASCII_printable_characters. For
 Binary, DynamoDB treats each byte of the binary data as unsigned when it
 compares binary values, for example when evaluating query expressions.
 For information on specifying data types in JSON, see JSON Data Format in
 the Amazon DynamoDB Developer Guide. ComparisonOperator - A comparator
 for evaluating attributes. For example, equals, greater than, less than,
 etc. The following comparison operators are available: EQ | NE | LE | LT
 | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN
 | BETWEEN For complete descriptions of all comparison operators, see
 Condition.</p></div></div><div class="top"><p class="src"><a name="v:sSegment" class="def">sSegment</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</p><div class="doc"><p>For a parallel Scan request, Segment identifies an individual segment to
 be scanned by an application worker. Segment IDs are zero-based, so the
 first segment is always 0. For example, if you want to scan a table using
 four application threads, the first thread specifies a Segment value of
 0, the second thread specifies 1, and so on. The value of
 LastEvaluatedKey returned from a parallel Scan request must be used as
 ExclusiveStartKey with the same segment ID in a subsequent Scan
 operation. The value for Segment must be greater than or equal to 0, and
 less than the value provided for TotalSegments. If you specify Segment,
 you must also specify TotalSegments.</p></div></div><div class="top"><p class="src"><a name="v:sSelect" class="def">sSelect</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:Select">Select</a>)</p><div class="doc"><p>The attributes to be returned in the result. You can retrieve all item
 attributes, specific item attributes, or the count of matching items.
 ALL_ATTRIBUTES - Returns all of the item attributes. COUNT - Returns the
 number of matching items, rather than the matching items themselves.
 SPECIFIC_ATTRIBUTES - Returns only the attributes listed in
 AttributesToGet. This return value is equivalent to specifying
 AttributesToGet without specifying any value for Select. If neither
 Select nor AttributesToGet are specified, DynamoDB defaults to
 ALL_ATTRIBUTES. You cannot use both AttributesToGet and Select together
 in a single request, unless the value for Select is SPECIFIC_ATTRIBUTES.
 (This usage is equivalent to specifying AttributesToGet without any value
 for Select.).</p></div></div><div class="top"><p class="src"><a name="v:sTableName" class="def">sTableName</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></p><div class="doc"><p>The name of the table containing the requested items.</p></div></div><div class="top"><p class="src"><a name="v:sTotalSegments" class="def">sTotalSegments</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:Scan">Scan</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Natural">Natural</a>)</p><div class="doc"><p>For a parallel Scan request, TotalSegments represents the total number of
 segments into which the Scan operation will be divided. The value of
 TotalSegments corresponds to the number of application workers that will
 perform the parallel scan. For example, if you want to scan a table using
 four application threads, specify a TotalSegments value of 4. The value
 for TotalSegments must be greater than or equal to 1, and less than or
 equal to 1000000. If you specify a TotalSegments value of 1, the Scan
 operation will be sequential rather than parallel. If you specify
 TotalSegments, you must also specify Segment.</p></div></div><h1 id="g:4">Response</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ScanResponse" class="def">ScanResponse</a></p><div class="subs instances"><p id="control.i:ScanResponse" class="caption collapser" onclick="toggleSection('i:ScanResponse')">Instances</p><div id="section.i:ScanResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../amazonka-core/Network-AWS-Data.html#t:FromJSON">FromJSON</a> <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:5">Response constructor</h2><div class="top"><p class="src"><a name="v:scanResponse" class="def">scanResponse</a> :: <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></p><div class="doc"><p><code><a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:srConsumedCapacity">srConsumedCapacity</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:ConsumedCapacity">ConsumedCapacity</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:srCount">srCount</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:srItems">srItems</a></code> <code>::</code> [<code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a></code>]</li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:srLastEvaluatedKey">srLastEvaluatedKey</a></code> <code>::</code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a></code> <code><a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a></code> <code><a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a></code></li><li><code><a href="Network-AWS-DynamoDB-Scan.html#v:srScannedCount">srScannedCount</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a></code></li></ul></div></div><h2 id="g:6">Response lenses</h2><div class="top"><p class="src"><a name="v:srConsumedCapacity" class="def">srConsumedCapacity</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DynamoDB-Types.html#t:ConsumedCapacity">ConsumedCapacity</a>)</p></div><div class="top"><p class="src"><a name="v:srCount" class="def">srCount</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a>)</p><div class="doc"><p>The number of items in the response. If you set ScanFilter in the
 request, then Count is the number of items returned after the filter was
 applied, and ScannedCount is the number of matching items before the
 filter was applied. If you did not use a filter in the request, then
 Count is the same as ScannedCount.</p></div></div><div class="top"><p class="src"><a name="v:srItems" class="def">srItems</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> [<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>]</p><div class="doc"><p>An array of item attributes that match the scan criteria. Each element in
 this array consists of an attribute name and the value for that
 attribute.</p></div></div><div class="top"><p class="src"><a name="v:srLastEvaluatedKey" class="def">srLastEvaluatedKey</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="../amazonka-core/Network-AWS-Prelude.html#t:HashMap">HashMap</a> <a href="../amazonka-core/Network-AWS-Prelude.html#t:Text">Text</a> <a href="Network-AWS-DynamoDB-Types.html#t:AttributeValue">AttributeValue</a>)</p><div class="doc"><p>The primary key of the item where the operation stopped, inclusive of the
 previous result set. Use this value to start a new operation, excluding
 this value in the new request. If LastEvaluatedKey is empty, then the
 &quot;last page&quot; of results has been processed and there is no more data to be
 retrieved. If LastEvaluatedKey is not empty, it does not necessarily mean
 that there is more data in the result set. The only way to know when you
 have reached the end of the result set is when LastEvaluatedKey is empty.</p></div></div><div class="top"><p class="src"><a name="v:srScannedCount" class="def">srScannedCount</a> :: Lens' <a href="Network-AWS-DynamoDB-Scan.html#t:ScanResponse">ScanResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.1/doc/html/Data-Int.html#t:Int">Int</a>)</p><div class="doc"><p>The number of items evaluated, before any ScanFilter is applied. A high
 ScannedCount value with few, or no, Count results indicates an
 inefficient Scan operation. For more information, see Count and
 ScannedCount in the Amazon DynamoDB Developer Guide. If you did not use a
 filter in the request, then ScannedCount is the same as Count.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>