<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.AWS.Kinesis.V2013_12_02</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Network-AWS-Kinesis-V2013_12_02.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">amazonka-kinesis-0.0.1.0: Amazon Kinesis SDK</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.AWS.Kinesis.V2013_12_02</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Amazon Kinesis is a managed service that scales elastically for real-time
 processing of streaming big data. The service takes in large streams of
 data records that can then be consumed in real time by multiple
 data-processing applications that can be run on Amazon EC2 instances.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:CreateStream">CreateStream</a> = <a href="#v:CreateStream">CreateStream</a> {<ul class="subs"><li><a href="#v:_csiShardCount">_csiShardCount</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:_csiStreamName">_csiStreamName</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:csiStreamName">csiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> Text</li><li class="src short"><a href="#v:csiShardCount">csiShardCount</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:CreateStreamResponse">CreateStreamResponse</a> = <a href="#v:CreateStreamResponse">CreateStreamResponse</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:DeleteStream">DeleteStream</a> = <a href="#v:DeleteStream">DeleteStream</a> {<ul class="subs"><li><a href="#v:_dsiStreamName">_dsiStreamName</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:dsiStreamName">dsiStreamName</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:DeleteStreamResponse">DeleteStreamResponse</a> = <a href="#v:DeleteStreamResponse">DeleteStreamResponse</a></li><li class="src short"><a href="#v:describeStream">describeStream</a> :: Text -&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:DescribeStream">DescribeStream</a> = <a href="#v:DescribeStream">DescribeStream</a> {<ul class="subs"><li><a href="#v:_dsjStreamName">_dsjStreamName</a> :: Text</li><li><a href="#v:_dsjLimit">_dsjLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:_dsjExclusiveStartShardId">_dsjExclusiveStartShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:dsjStreamName">dsjStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> Text</li><li class="src short"><a href="#v:dsjLimit">dsjLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:dsjExclusiveStartShardId">dsjExclusiveStartShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><span class="keyword">data</span> <a href="#t:DescribeStreamResponse">DescribeStreamResponse</a> = <a href="#v:DescribeStreamResponse">DescribeStreamResponse</a> {<ul class="subs"><li><a href="#v:_dsoStreamDescription">_dsoStreamDescription</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></li></ul>}</li><li class="src short"><a href="#v:dsoStreamDescription">dsoStreamDescription</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></li><li class="src short"><a href="#v:getRecords">getRecords</a> :: Text -&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:GetRecords">GetRecords</a> = <a href="#v:GetRecords">GetRecords</a> {<ul class="subs"><li><a href="#v:_griShardIterator">_griShardIterator</a> :: Text</li><li><a href="#v:_griLimit">_griLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></li></ul>}</li><li class="src short"><a href="#v:griShardIterator">griShardIterator</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> Text</li><li class="src short"><a href="#v:griLimit">griLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:GetRecordsResponse">GetRecordsResponse</a> = <a href="#v:GetRecordsResponse">GetRecordsResponse</a> {<ul class="subs"><li><a href="#v:_groRecords">_groRecords</a> :: [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a>]</li><li><a href="#v:_groNextShardIterator">_groNextShardIterator</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:groRecords">groRecords</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a> [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a>]</li><li class="src short"><a href="#v:groNextShardIterator">groNextShardIterator</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:getShardIterator">getShardIterator</a> :: Text -&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a> -&gt; Text -&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:GetShardIterator">GetShardIterator</a> = <a href="#v:GetShardIterator">GetShardIterator</a> {<ul class="subs"><li><a href="#v:_gsiiShardId">_gsiiShardId</a> :: Text</li><li><a href="#v:_gsiiShardIteratorType">_gsiiShardIteratorType</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></li><li><a href="#v:_gsiiStreamName">_gsiiStreamName</a> :: Text</li><li><a href="#v:_gsiiStartingSequenceNumber">_gsiiStartingSequenceNumber</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:gsiiStreamName">gsiiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> Text</li><li class="src short"><a href="#v:gsiiStartingSequenceNumber">gsiiStartingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:gsiiShardIteratorType">gsiiShardIteratorType</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></li><li class="src short"><a href="#v:gsiiShardId">gsiiShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:GetShardIteratorResponse">GetShardIteratorResponse</a> = <a href="#v:GetShardIteratorResponse">GetShardIteratorResponse</a> {<ul class="subs"><li><a href="#v:_gsioShardIterator">_gsioShardIterator</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:gsioShardIterator">gsioShardIterator</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:listStreams">listStreams</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ListStreams">ListStreams</a> = <a href="#v:ListStreams">ListStreams</a> {<ul class="subs"><li><a href="#v:_lsiLimit">_lsiLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:_lsiExclusiveStartStreamName">_lsiExclusiveStartStreamName</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:lsiLimit">lsiLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:lsiExclusiveStartStreamName">lsiExclusiveStartStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><span class="keyword">data</span> <a href="#t:ListStreamsResponse">ListStreamsResponse</a> = <a href="#v:ListStreamsResponse">ListStreamsResponse</a> {<ul class="subs"><li><a href="#v:_lsoHasMoreStreams">_lsoHasMoreStreams</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li><a href="#v:_lsoStreamNames">_lsoStreamNames</a> :: [Text]</li></ul>}</li><li class="src short"><a href="#v:lsoStreamNames">lsoStreamNames</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a> [Text]</li><li class="src short"><a href="#v:lsoHasMoreStreams">lsoHasMoreStreams</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:MergeShards">MergeShards</a> = <a href="#v:MergeShards">MergeShards</a> {<ul class="subs"><li><a href="#v:_msiShardToMerge">_msiShardToMerge</a> :: Text</li><li><a href="#v:_msiAdjacentShardToMerge">_msiAdjacentShardToMerge</a> :: Text</li><li><a href="#v:_msiStreamName">_msiStreamName</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:msiStreamName">msiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</li><li class="src short"><a href="#v:msiShardToMerge">msiShardToMerge</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</li><li class="src short"><a href="#v:msiAdjacentShardToMerge">msiAdjacentShardToMerge</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:MergeShardsResponse">MergeShardsResponse</a> = <a href="#v:MergeShardsResponse">MergeShardsResponse</a></li><li class="src short"><a href="#v:putRecord">putRecord</a> :: Base64 -&gt; Text -&gt; Text -&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:PutRecord">PutRecord</a> = <a href="#v:PutRecord">PutRecord</a> {<ul class="subs"><li><a href="#v:_priData">_priData</a> :: Base64</li><li><a href="#v:_priPartitionKey">_priPartitionKey</a> :: Text</li><li><a href="#v:_priStreamName">_priStreamName</a> :: Text</li><li><a href="#v:_priExplicitHashKey">_priExplicitHashKey</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li><li><a href="#v:_priSequenceNumberForOrdering">_priSequenceNumberForOrdering</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><a href="#v:priStreamName">priStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Text</li><li class="src short"><a href="#v:priSequenceNumberForOrdering">priSequenceNumberForOrdering</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:priPartitionKey">priPartitionKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Text</li><li class="src short"><a href="#v:priExplicitHashKey">priExplicitHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:priData">priData</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Base64</li><li class="src short"><span class="keyword">data</span> <a href="#t:PutRecordResponse">PutRecordResponse</a> = <a href="#v:PutRecordResponse">PutRecordResponse</a> {<ul class="subs"><li><a href="#v:_proSequenceNumber">_proSequenceNumber</a> :: Text</li><li><a href="#v:_proShardId">_proShardId</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:proShardId">proShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a> Text</li><li class="src short"><a href="#v:proSequenceNumber">proSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:SplitShard">SplitShard</a> = <a href="#v:SplitShard">SplitShard</a> {<ul class="subs"><li><a href="#v:_ssiNewStartingHashKey">_ssiNewStartingHashKey</a> :: Text</li><li><a href="#v:_ssiShardToSplit">_ssiShardToSplit</a> :: Text</li><li><a href="#v:_ssiStreamName">_ssiStreamName</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:ssiStreamName">ssiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</li><li class="src short"><a href="#v:ssiShardToSplit">ssiShardToSplit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</li><li class="src short"><a href="#v:ssiNewStartingHashKey">ssiNewStartingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:SplitShardResponse">SplitShardResponse</a> = <a href="#v:SplitShardResponse">SplitShardResponse</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Kinesis">Kinesis</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ShardIteratorType">ShardIteratorType</a><ul class="subs"><li>= <a href="#v:ShardIteratorTypeAfterSequenceNumber">ShardIteratorTypeAfterSequenceNumber</a></li><li>| <a href="#v:ShardIteratorTypeAtSequenceNumber">ShardIteratorTypeAtSequenceNumber</a></li><li>| <a href="#v:ShardIteratorTypeLatest">ShardIteratorTypeLatest</a></li><li>| <a href="#v:ShardIteratorTypeTrimHorizon">ShardIteratorTypeTrimHorizon</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:StreamStatus">StreamStatus</a><ul class="subs"><li>= <a href="#v:StreamStatusActive">StreamStatusActive</a></li><li>| <a href="#v:StreamStatusCreating">StreamStatusCreating</a></li><li>| <a href="#v:StreamStatusDeleting">StreamStatusDeleting</a></li><li>| <a href="#v:StreamStatusUpdating">StreamStatusUpdating</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:HashKeyRange">HashKeyRange</a> = <a href="#v:HashKeyRange">HashKeyRange</a> {<ul class="subs"><li><a href="#v:_hkrEndingHashKey">_hkrEndingHashKey</a> :: Text</li><li><a href="#v:_hkrStartingHashKey">_hkrStartingHashKey</a> :: Text</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Record">Record</a> = <a href="#v:Record">Record</a> {<ul class="subs"><li><a href="#v:_rSequenceNumber">_rSequenceNumber</a> :: Text</li><li><a href="#v:_rPartitionKey">_rPartitionKey</a> :: Text</li><li><a href="#v:_rData">_rData</a> :: Base64</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:SequenceNumberRange">SequenceNumberRange</a> = <a href="#v:SequenceNumberRange">SequenceNumberRange</a> {<ul class="subs"><li><a href="#v:_snrStartingSequenceNumber">_snrStartingSequenceNumber</a> :: Text</li><li><a href="#v:_snrEndingSequenceNumber">_snrEndingSequenceNumber</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Shard">Shard</a> = <a href="#v:Shard">Shard</a> {<ul class="subs"><li><a href="#v:_sAdjacentParentShardId">_sAdjacentParentShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li><li><a href="#v:_sHashKeyRange">_sHashKeyRange</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></li><li><a href="#v:_sParentShardId">_sParentShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li><li><a href="#v:_sSequenceNumberRange">_sSequenceNumberRange</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></li><li><a href="#v:_sShardId">_sShardId</a> :: Text</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:StreamDescription">StreamDescription</a> = <a href="#v:StreamDescription">StreamDescription</a> {<ul class="subs"><li><a href="#v:_sdStreamStatus">_sdStreamStatus</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></li><li><a href="#v:_sdHasMoreShards">_sdHasMoreShards</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li><a href="#v:_sdStreamARN">_sdStreamARN</a> :: Text</li><li><a href="#v:_sdShards">_sdShards</a> :: [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a>]</li><li><a href="#v:_sdStreamName">_sdStreamName</a> :: Text</li></ul>}</li><li class="src short"><a href="#v:hkrStartingHashKey">hkrStartingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a> Text</li><li class="src short"><a href="#v:hkrEndingHashKey">hkrEndingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a> Text</li><li class="src short"><a href="#v:rSequenceNumber">rSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Text</li><li class="src short"><a href="#v:rPartitionKey">rPartitionKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Text</li><li class="src short"><a href="#v:rData">rData</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Base64</li><li class="src short"><a href="#v:snrStartingSequenceNumber">snrStartingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a> Text</li><li class="src short"><a href="#v:snrEndingSequenceNumber">snrEndingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:sShardId">sShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> Text</li><li class="src short"><a href="#v:sSequenceNumberRange">sSequenceNumberRange</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></li><li class="src short"><a href="#v:sParentShardId">sParentShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:sHashKeyRange">sHashKeyRange</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></li><li class="src short"><a href="#v:sAdjacentParentShardId">sAdjacentParentShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:sdStreamStatus">sdStreamStatus</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></li><li class="src short"><a href="#v:sdStreamName">sdStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> Text</li><li class="src short"><a href="#v:sdStreamARN">sdStreamARN</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> Text</li><li class="src short"><a href="#v:sdShards">sdShards</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a>]</li><li class="src short"><a href="#v:sdHasMoreShards">sdHasMoreShards</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CreateStream" class="def">CreateStream</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CreateStream" class="def">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_csiShardCount" class="def">_csiShardCount</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></dt><dd class="doc"><p>The number of shards that the stream will use. The throughput of
 the stream is a function of the number of shards; more shards are
 required for greater provisioned throughput. Note: The default
 limit for an AWS account is 10 shards per stream. If you need to
 create a stream with more than 10 shards, contact AWS Support to
 increase the limit on your account.</p></dd><dt class="src"><a name="v:_csiStreamName" class="def">_csiStreamName</a> :: Text</dt><dd class="doc"><p>A name to identify the stream. The stream name is scoped to the
 AWS account used by the application that creates the stream. It
 is also scoped by region. That is, two streams in two different
 AWS accounts can have the same name, and two streams in the same
 AWS account, but in two different regions, can have the same
 name.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:CreateStream" class="caption collapser" onclick="toggleSection('i:CreateStream')">Instances</p><div id="section.i:CreateStream" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStreamResponse">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:csiStreamName" class="def">csiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> Text</p></div><div class="top"><p class="src"><a name="v:csiShardCount" class="def">csiShardCount</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStream">CreateStream</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CreateStreamResponse" class="def">CreateStreamResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CreateStreamResponse" class="def">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:CreateStreamResponse" class="caption collapser" onclick="toggleSection('i:CreateStreamResponse')">Instances</p><div id="section.i:CreateStreamResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStreamResponse">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStreamResponse">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStreamResponse">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:CreateStreamResponse">CreateStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DeleteStream" class="def">DeleteStream</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DeleteStream" class="def">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_dsiStreamName" class="def">_dsiStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream to delete.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DeleteStream" class="caption collapser" onclick="toggleSection('i:DeleteStream')">Instances</p><div id="section.i:DeleteStream" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStreamResponse">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:dsiStreamName" class="def">dsiStreamName</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStream">DeleteStream</a> Text</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DeleteStreamResponse" class="def">DeleteStreamResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DeleteStreamResponse" class="def">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:DeleteStreamResponse" class="caption collapser" onclick="toggleSection('i:DeleteStreamResponse')">Instances</p><div id="section.i:DeleteStreamResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStreamResponse">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStreamResponse">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStreamResponse">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DeleteStreamResponse">DeleteStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:describeStream" class="def">describeStream</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_dsjStreamName">_dsjStreamName</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Minimum specification for a <code><a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DescribeStream" class="def">DescribeStream</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DescribeStream" class="def">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_dsjStreamName" class="def">_dsjStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream to describe.</p></dd><dt class="src"><a name="v:_dsjLimit" class="def">_dsjLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></dt><dd class="doc"><p>The maximum number of shards to return.</p></dd><dt class="src"><a name="v:_dsjExclusiveStartShardId" class="def">_dsjExclusiveStartShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The shard ID of the shard to start with for the stream
 description.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DescribeStream" class="caption collapser" onclick="toggleSection('i:DescribeStream')">Instances</p><div id="section.i:DescribeStream" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSPager <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:dsjStreamName" class="def">dsjStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> Text</p></div><div class="top"><p class="src"><a name="v:dsjLimit" class="def">dsjLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</p></div><div class="top"><p class="src"><a name="v:dsjExclusiveStartShardId" class="def">dsjExclusiveStartShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStream">DescribeStream</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DescribeStreamResponse" class="def">DescribeStreamResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DescribeStreamResponse" class="def">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_dsoStreamDescription" class="def">_dsoStreamDescription</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></dt><dd class="doc"><p>Contains the current status of the stream, the stream ARN, an
 array of shard objects that comprise the stream, and states
 whether there are more shards available.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DescribeStreamResponse" class="caption collapser" onclick="toggleSection('i:DescribeStreamResponse')">Instances</p><div id="section.i:DescribeStreamResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:dsoStreamDescription" class="def">dsoStreamDescription</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:DescribeStreamResponse">DescribeStreamResponse</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></p></div><div class="top"><p class="src"><a name="v:getRecords" class="def">getRecords</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_griShardIterator">_griShardIterator</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Minimum specification for a <code><a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GetRecords" class="def">GetRecords</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GetRecords" class="def">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_griShardIterator" class="def">_griShardIterator</a> :: Text</dt><dd class="doc"><p>The position in the shard from which you want to start
 sequentially reading data records.</p></dd><dt class="src"><a name="v:_griLimit" class="def">_griLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></dt><dd class="doc"><p>The maximum number of records to return, which can be set to a
 value of up to 10,000.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:GetRecords" class="caption collapser" onclick="toggleSection('i:GetRecords')">Instances</p><div id="section.i:GetRecords" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:griShardIterator" class="def">griShardIterator</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> Text</p></div><div class="top"><p class="src"><a name="v:griLimit" class="def">griLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecords">GetRecords</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GetRecordsResponse" class="def">GetRecordsResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GetRecordsResponse" class="def">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_groRecords" class="def">_groRecords</a> :: [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a>]</dt><dd class="doc"><p>The data records retrieved from the shard.</p></dd><dt class="src"><a name="v:_groNextShardIterator" class="def">_groNextShardIterator</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The next position in the shard from which to start sequentially
 reading data records. If set to null, the shard has been closed
 and the requested iterator will not return any more data.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:GetRecordsResponse" class="caption collapser" onclick="toggleSection('i:GetRecordsResponse')">Instances</p><div id="section.i:GetRecordsResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:groRecords" class="def">groRecords</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a> [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a>]</p></div><div class="top"><p class="src"><a name="v:groNextShardIterator" class="def">groNextShardIterator</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetRecordsResponse">GetRecordsResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:getShardIterator" class="def">getShardIterator</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_gsiiShardId">_gsiiShardId</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_gsiiShardIteratorType">_gsiiShardIteratorType</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_gsiiStreamName">_gsiiStreamName</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Minimum specification for a <code><a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GetShardIterator" class="def">GetShardIterator</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GetShardIterator" class="def">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_gsiiShardId" class="def">_gsiiShardId</a> :: Text</dt><dd class="doc"><p>The shard ID of the shard to get the iterator for.</p></dd><dt class="src"><a name="v:_gsiiShardIteratorType" class="def">_gsiiShardIteratorType</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></dt><dd class="doc"><p>Determines how the shard iterator is used to start reading data
 records from the shard. The following are the valid shard
 iterator types: AT_SEQUENCE_NUMBER - Start reading exactly from
 the position denoted by a specific sequence number.
 AFTER_SEQUENCE_NUMBER - Start reading right after the position
 denoted by a specific sequence number. TRIM_HORIZON - Start
 reading at the last untrimmed record in the shard in the system,
 which is the oldest data record in the shard. LATEST - Start
 reading just after the most recent record in the shard, so that
 you always read the most recent data in the shard.</p></dd><dt class="src"><a name="v:_gsiiStreamName" class="def">_gsiiStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream.</p></dd><dt class="src"><a name="v:_gsiiStartingSequenceNumber" class="def">_gsiiStartingSequenceNumber</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The sequence number of the data record in the shard from which to
 start reading from.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:GetShardIterator" class="caption collapser" onclick="toggleSection('i:GetShardIterator')">Instances</p><div id="section.i:GetShardIterator" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:gsiiStreamName" class="def">gsiiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> Text</p></div><div class="top"><p class="src"><a name="v:gsiiStartingSequenceNumber" class="def">gsiiStartingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:gsiiShardIteratorType" class="def">gsiiShardIteratorType</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></p></div><div class="top"><p class="src"><a name="v:gsiiShardId" class="def">gsiiShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIterator">GetShardIterator</a> Text</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GetShardIteratorResponse" class="def">GetShardIteratorResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GetShardIteratorResponse" class="def">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_gsioShardIterator" class="def">_gsioShardIterator</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The position in the shard from which to start reading data
 records sequentially. A shard iterator specifies this position
 using the sequence number of a data record in a shard.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:GetShardIteratorResponse" class="caption collapser" onclick="toggleSection('i:GetShardIteratorResponse')">Instances</p><div id="section.i:GetShardIteratorResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:gsioShardIterator" class="def">gsioShardIterator</a> :: Iso' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:GetShardIteratorResponse">GetShardIteratorResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:listStreams" class="def">listStreams</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></p><div class="doc"><p>Minimum specification for a <code><a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ListStreams" class="def">ListStreams</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ListStreams" class="def">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_lsiLimit" class="def">_lsiLimit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></dt><dd class="doc"><p>The maximum number of streams to list.</p></dd><dt class="src"><a name="v:_lsiExclusiveStartStreamName" class="def">_lsiExclusiveStartStreamName</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The name of the stream to start the list with.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:ListStreams" class="caption collapser" onclick="toggleSection('i:ListStreams')">Instances</p><div id="section.i:ListStreams" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSPager <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:lsiLimit" class="def">lsiLimit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a>)</p></div><div class="top"><p class="src"><a name="v:lsiExclusiveStartStreamName" class="def">lsiExclusiveStartStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreams">ListStreams</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ListStreamsResponse" class="def">ListStreamsResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ListStreamsResponse" class="def">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_lsoHasMoreStreams" class="def">_lsoHasMoreStreams</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc"><p>If set to true, there are more streams available to list.</p></dd><dt class="src"><a name="v:_lsoStreamNames" class="def">_lsoStreamNames</a> :: [Text]</dt><dd class="doc"><p>The names of the streams that are associated with the AWS account
 making the ListStreams request.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:ListStreamsResponse" class="caption collapser" onclick="toggleSection('i:ListStreamsResponse')">Instances</p><div id="section.i:ListStreamsResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:lsoStreamNames" class="def">lsoStreamNames</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a> [Text]</p></div><div class="top"><p class="src"><a name="v:lsoHasMoreStreams" class="def">lsoHasMoreStreams</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ListStreamsResponse">ListStreamsResponse</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:MergeShards" class="def">MergeShards</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:MergeShards" class="def">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_msiShardToMerge" class="def">_msiShardToMerge</a> :: Text</dt><dd class="doc"><p>The shard ID of the shard to combine with the adjacent shard for
 the merge.</p></dd><dt class="src"><a name="v:_msiAdjacentShardToMerge" class="def">_msiAdjacentShardToMerge</a> :: Text</dt><dd class="doc"><p>The shard ID of the adjacent shard for the merge.</p></dd><dt class="src"><a name="v:_msiStreamName" class="def">_msiStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream for the merge.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:MergeShards" class="caption collapser" onclick="toggleSection('i:MergeShards')">Instances</p><div id="section.i:MergeShards" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShardsResponse">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:msiStreamName" class="def">msiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</p></div><div class="top"><p class="src"><a name="v:msiShardToMerge" class="def">msiShardToMerge</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</p></div><div class="top"><p class="src"><a name="v:msiAdjacentShardToMerge" class="def">msiAdjacentShardToMerge</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShards">MergeShards</a> Text</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:MergeShardsResponse" class="def">MergeShardsResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:MergeShardsResponse" class="def">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:MergeShardsResponse" class="caption collapser" onclick="toggleSection('i:MergeShardsResponse')">Instances</p><div id="section.i:MergeShardsResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShardsResponse">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShardsResponse">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShardsResponse">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:MergeShardsResponse">MergeShardsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:putRecord" class="def">putRecord</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Base64</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_priData">_priData</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_priPartitionKey">_priPartitionKey</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Kinesis-V2013_12_02.html#v:_priStreamName">_priStreamName</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Minimum specification for a <code><a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></code> request.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PutRecord" class="def">PutRecord</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:PutRecord" class="def">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_priData" class="def">_priData</a> :: Base64</dt><dd class="doc"><p>The data blob to put into the record, which is Base64-encoded
 when the blob is serialized. The maximum size of the data blob
 (the payload after Base64-decoding) is 50 kilobytes (KB).</p></dd><dt class="src"><a name="v:_priPartitionKey" class="def">_priPartitionKey</a> :: Text</dt><dd class="doc"><p>Determines which shard in the stream the data record is assigned
 to. Partition keys are Unicode strings with a maximum length
 limit of 256 bytes. Amazon Kinesis uses the partition key as
 input to a hash function that maps the partition key and
 associated data to a specific shard. Specifically, an MD5 hash
 function is used to map partition keys to 128-bit integer values
 and to map associated data records to shards. As a result of this
 hashing mechanism, all data records with the same partition key
 will map to the same shard within the stream.</p></dd><dt class="src"><a name="v:_priStreamName" class="def">_priStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream to put the data record into.</p></dd><dt class="src"><a name="v:_priExplicitHashKey" class="def">_priExplicitHashKey</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The hash value used to explicitly determine the shard the data
 record is assigned to by overriding the partition key hash.</p></dd><dt class="src"><a name="v:_priSequenceNumberForOrdering" class="def">_priSequenceNumberForOrdering</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>Guarantees strictly increasing sequence numbers, for puts from
 the same client and to the same partition key. Usage: set the
 SequenceNumberForOrdering of record n to the sequence number of
 record n-1 (as returned in the PutRecordResult when putting
 record n-1). If this parameter is not set, records will be
 coarsely ordered based on arrival time.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:PutRecord" class="caption collapser" onclick="toggleSection('i:PutRecord')">Instances</p><div id="section.i:PutRecord" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:priStreamName" class="def">priStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Text</p></div><div class="top"><p class="src"><a name="v:priSequenceNumberForOrdering" class="def">priSequenceNumberForOrdering</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:priPartitionKey" class="def">priPartitionKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Text</p></div><div class="top"><p class="src"><a name="v:priExplicitHashKey" class="def">priExplicitHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:priData" class="def">priData</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecord">PutRecord</a> Base64</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PutRecordResponse" class="def">PutRecordResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:PutRecordResponse" class="def">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_proSequenceNumber" class="def">_proSequenceNumber</a> :: Text</dt><dd class="doc"><p>The sequence number identifier that was assigned to the put data
 record. The sequence number for the record is unique across all
 records in the stream. A sequence number is the identifier
 associated with every record put into the stream.</p></dd><dt class="src"><a name="v:_proShardId" class="def">_proShardId</a> :: Text</dt><dd class="doc"><p>The shard ID of the shard where the data record was placed.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:PutRecordResponse" class="caption collapser" onclick="toggleSection('i:PutRecordResponse')">Instances</p><div id="section.i:PutRecordResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:proShardId" class="def">proShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a> Text</p></div><div class="top"><p class="src"><a name="v:proSequenceNumber" class="def">proSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:PutRecordResponse">PutRecordResponse</a> Text</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:SplitShard" class="def">SplitShard</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SplitShard" class="def">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_ssiNewStartingHashKey" class="def">_ssiNewStartingHashKey</a> :: Text</dt><dd class="doc"><p>A hash key value for the starting hash key of one of the child
 shards created by the split. The hash key range for a given shard
 constitutes a set of ordered contiguous positive integers. The
 value for NewStartingHashKey must be in the range of hash keys
 being mapped into the shard. The NewStartingHashKey hash key
 value and all higher hash key values in hash key range are
 distributed to one of the child shards. All the lower hash key
 values in the range are distributed to the other child shard.</p></dd><dt class="src"><a name="v:_ssiShardToSplit" class="def">_ssiShardToSplit</a> :: Text</dt><dd class="doc"><p>The shard ID of the shard to split.</p></dd><dt class="src"><a name="v:_ssiStreamName" class="def">_ssiStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream for the shard split.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:SplitShard" class="caption collapser" onclick="toggleSection('i:SplitShard')">Instances</p><div id="section.i:SplitShard" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> = <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShardResponse">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:ssiStreamName" class="def">ssiStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</p></div><div class="top"><p class="src"><a name="v:ssiShardToSplit" class="def">ssiShardToSplit</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</p></div><div class="top"><p class="src"><a name="v:ssiNewStartingHashKey" class="def">ssiNewStartingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShard">SplitShard</a> Text</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:SplitShardResponse" class="def">SplitShardResponse</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SplitShardResponse" class="def">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:SplitShardResponse" class="caption collapser" onclick="toggleSection('i:SplitShardResponse')">Instances</p><div id="section.i:SplitShardResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShardResponse">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShardResponse">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShardResponse">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SplitShardResponse">SplitShardResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Kinesis" class="def">Kinesis</a></p><div class="doc"><p>Supported version (<code>2013-12-02</code>) of the
 <code>Amazon Kinesis</code> service.</p></div><div class="subs instances"><p id="control.i:Kinesis" class="caption collapser" onclick="toggleSection('i:Kinesis')">Instances</p><div id="section.i:Kinesis" class="show"><table><tr><td class="src">AWSService <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> * <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Exception-Base.html#t:Exception">Exception</a> (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSServiceError (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSError (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sg <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a> = V4</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">data</span> Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a> <ul class="inst"><li class="inst">= <a name="v:ExpiredIteratorException" class="def">ExpiredIteratorException</a> { <ul class="subs"><li><a name="v:_eieMessage" class="def">_eieMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li><li class="inst">| <a name="v:InvalidArgumentException" class="def">InvalidArgumentException</a> { <ul class="subs"><li><a name="v:_iaeMessage" class="def">_iaeMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li><li class="inst">| <a name="v:KinesisClient" class="def">KinesisClient</a> HttpException</li><li class="inst">| <a name="v:KinesisSerializer" class="def">KinesisSerializer</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li><li class="inst">| <a name="v:KinesisService" class="def">KinesisService</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li><li class="inst">| <a name="v:LimitExceededException" class="def">LimitExceededException</a> { <ul class="subs"><li><a name="v:_leeMessage" class="def">_leeMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li><li class="inst">| <a name="v:ProvisionedThroughputExceededException" class="def">ProvisionedThroughputExceededException</a> { <ul class="subs"><li><a name="v:_pteeMessage" class="def">_pteeMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li><li class="inst">| <a name="v:ResourceInUseException" class="def">ResourceInUseException</a> { <ul class="subs"><li><a name="v:_riueMessage" class="def">_riueMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li><li class="inst">| <a name="v:ResourceNotFoundException" class="def">ResourceNotFoundException</a> { <ul class="subs"><li><a name="v:_rnfeMessage" class="def">_rnfeMessage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</li></ul> }</li></ul></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> (Er <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Kinesis">Kinesis</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ShardIteratorType" class="def">ShardIteratorType</a></p><div class="doc"><p>Determines how the shard iterator is used to start reading data records
 from the shard. The following are the valid shard iterator types:
 AT_SEQUENCE_NUMBER - Start reading exactly from the position denoted by a
 specific sequence number. AFTER_SEQUENCE_NUMBER - Start reading right after
 the position denoted by a specific sequence number. TRIM_HORIZON - Start
 reading at the last untrimmed record in the shard in the system, which is
 the oldest data record in the shard. LATEST - Start reading just after the
 most recent record in the shard, so that you always read the most recent
 data in the shard.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ShardIteratorTypeAfterSequenceNumber" class="def">ShardIteratorTypeAfterSequenceNumber</a></td><td class="doc"><p>AFTER_SEQUENCE_NUMBER</p></td></tr><tr><td class="src"><a name="v:ShardIteratorTypeAtSequenceNumber" class="def">ShardIteratorTypeAtSequenceNumber</a></td><td class="doc"><p>AT_SEQUENCE_NUMBER</p></td></tr><tr><td class="src"><a name="v:ShardIteratorTypeLatest" class="def">ShardIteratorTypeLatest</a></td><td class="doc"><p>LATEST</p></td></tr><tr><td class="src"><a name="v:ShardIteratorTypeTrimHorizon" class="def">ShardIteratorTypeTrimHorizon</a></td><td class="doc"><p>TRIM_HORIZON</p></td></tr></table></div><div class="subs instances"><p id="control.i:ShardIteratorType" class="caption collapser" onclick="toggleSection('i:ShardIteratorType')">Instances</p><div id="section.i:ShardIteratorType" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Hashable <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToText <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromText <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeader <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToByteString <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:ShardIteratorType">ShardIteratorType</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:StreamStatus" class="def">StreamStatus</a></p><div class="doc"><p>The current status of the stream being described. The stream status is one
 of the following states: CREATING - The stream is being created. Upon
 receiving a CreateStream request, Amazon Kinesis immediately returns and
 sets StreamStatus to CREATING. DELETING - The stream is being deleted.
 After a DeleteStream request, the specified stream is in the DELETING state
 until Amazon Kinesis completes the deletion. ACTIVE - The stream exists and
 is ready for read and write operations or deletion. You should perform read
 and write operations only on an ACTIVE stream. UPDATING - Shards in the
 stream are being merged or split. Read and write operations continue to
 work while the stream is in the UPDATING state.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:StreamStatusActive" class="def">StreamStatusActive</a></td><td class="doc"><p>ACTIVE</p></td></tr><tr><td class="src"><a name="v:StreamStatusCreating" class="def">StreamStatusCreating</a></td><td class="doc"><p>CREATING</p></td></tr><tr><td class="src"><a name="v:StreamStatusDeleting" class="def">StreamStatusDeleting</a></td><td class="doc"><p>DELETING</p></td></tr><tr><td class="src"><a name="v:StreamStatusUpdating" class="def">StreamStatusUpdating</a></td><td class="doc"><p>UPDATING</p></td></tr></table></div><div class="subs instances"><p id="control.i:StreamStatus" class="caption collapser" onclick="toggleSection('i:StreamStatus')">Instances</p><div id="section.i:StreamStatus" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Hashable <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToText <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromText <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeader <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToByteString <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HashKeyRange" class="def">HashKeyRange</a></p><div class="doc"><p>The range of possible hash key values for the shard, which is a set of
 ordered contiguous positive integers.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HashKeyRange" class="def">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_hkrEndingHashKey" class="def">_hkrEndingHashKey</a> :: Text</dt><dd class="doc"><p>The ending hash key of the hash key range.</p></dd><dt class="src"><a name="v:_hkrStartingHashKey" class="def">_hkrStartingHashKey</a> :: Text</dt><dd class="doc"><p>The starting hash key of the hash key range.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:HashKeyRange" class="caption collapser" onclick="toggleSection('i:HashKeyRange')">Instances</p><div id="section.i:HashKeyRange" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Record" class="def">Record</a></p><div class="doc"><p>The unit of data of the Amazon Kinesis stream, which is composed of a
 sequence number, a partition key, and a data blob.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Record" class="def">Record</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_rSequenceNumber" class="def">_rSequenceNumber</a> :: Text</dt><dd class="doc"><p>The unique identifier for the record in the Amazon Kinesis
 stream.</p></dd><dt class="src"><a name="v:_rPartitionKey" class="def">_rPartitionKey</a> :: Text</dt><dd class="doc"><p>Identifies which shard in the stream the data record is assigned
 to.</p></dd><dt class="src"><a name="v:_rData" class="def">_rData</a> :: Base64</dt><dd class="doc"><p>The data blob. The data in the blob is both opaque and immutable
 to the Amazon Kinesis service, which does not inspect, interpret,
 or change the data in the blob in any way. The maximum size of
 the data blob (the payload after Base64-decoding) is 50 kilobytes
 (KB).</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Record" class="caption collapser" onclick="toggleSection('i:Record')">Instances</p><div id="section.i:Record" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:SequenceNumberRange" class="def">SequenceNumberRange</a></p><div class="doc"><p>The range of possible sequence numbers for the shard.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SequenceNumberRange" class="def">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_snrStartingSequenceNumber" class="def">_snrStartingSequenceNumber</a> :: Text</dt><dd class="doc"><p>The starting sequence number for the range.</p></dd><dt class="src"><a name="v:_snrEndingSequenceNumber" class="def">_snrEndingSequenceNumber</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The ending sequence number for the range. Shards that are in the
 OPEN state have an ending sequence number of null.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:SequenceNumberRange" class="caption collapser" onclick="toggleSection('i:SequenceNumberRange')">Instances</p><div id="section.i:SequenceNumberRange" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Shard" class="def">Shard</a></p><div class="doc"><p>A uniquely identified group of data records in an Amazon Kinesis stream.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Shard" class="def">Shard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_sAdjacentParentShardId" class="def">_sAdjacentParentShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The shard Id of the shard adjacent to the shard's parent.</p></dd><dt class="src"><a name="v:_sHashKeyRange" class="def">_sHashKeyRange</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></dt><dd class="doc"><p>The range of possible hash key values for the shard, which is a
 set of ordered contiguous positive integers.</p></dd><dt class="src"><a name="v:_sParentShardId" class="def">_sParentShardId</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text</dt><dd class="doc"><p>The shard Id of the shard's parent.</p></dd><dt class="src"><a name="v:_sSequenceNumberRange" class="def">_sSequenceNumberRange</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></dt><dd class="doc"><p>The range of possible sequence numbers for the shard.</p></dd><dt class="src"><a name="v:_sShardId" class="def">_sShardId</a> :: Text</dt><dd class="doc"><p>The unique identifier of the shard within the Amazon Kinesis
 stream.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Shard" class="caption collapser" onclick="toggleSection('i:Shard')">Instances</p><div id="section.i:Shard" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:StreamDescription" class="def">StreamDescription</a></p><div class="doc"><p>Contains the current status of the stream, the stream ARN, an array of
 shard objects that comprise the stream, and states whether there are more
 shards available.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:StreamDescription" class="def">StreamDescription</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_sdStreamStatus" class="def">_sdStreamStatus</a> :: <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></dt><dd class="doc"><p>The current status of the stream being described. The stream
 status is one of the following states: CREATING - The stream is
 being created. Upon receiving a CreateStream request, Amazon
 Kinesis immediately returns and sets StreamStatus to CREATING.
 DELETING - The stream is being deleted. After a DeleteStream
 request, the specified stream is in the DELETING state until
 Amazon Kinesis completes the deletion. ACTIVE - The stream exists
 and is ready for read and write operations or deletion. You
 should perform read and write operations only on an ACTIVE
 stream. UPDATING - Shards in the stream are being merged or
 split. Read and write operations continue to work while the
 stream is in the UPDATING state.</p></dd><dt class="src"><a name="v:_sdHasMoreShards" class="def">_sdHasMoreShards</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc"><p>If set to true there are more shards in the stream available to
 describe.</p></dd><dt class="src"><a name="v:_sdStreamARN" class="def">_sdStreamARN</a> :: Text</dt><dd class="doc"><p>The Amazon Resource Name (ARN) for the stream being described.</p></dd><dt class="src"><a name="v:_sdShards" class="def">_sdShards</a> :: [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a>]</dt><dd class="doc"><p>The shards that comprise the stream.</p></dd><dt class="src"><a name="v:_sdStreamName" class="def">_sdStreamName</a> :: Text</dt><dd class="doc"><p>The name of the stream being described.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:StreamDescription" class="caption collapser" onclick="toggleSection('i:StreamDescription')">Instances</p><div id="section.i:StreamDescription" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Generic">Generic</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/GHC-Generics.html#t:Rep">Rep</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hkrStartingHashKey" class="def">hkrStartingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a> Text</p></div><div class="top"><p class="src"><a name="v:hkrEndingHashKey" class="def">hkrEndingHashKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a> Text</p></div><div class="top"><p class="src"><a name="v:rSequenceNumber" class="def">rSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Text</p></div><div class="top"><p class="src"><a name="v:rPartitionKey" class="def">rPartitionKey</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Text</p></div><div class="top"><p class="src"><a name="v:rData" class="def">rData</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Record">Record</a> Base64</p></div><div class="top"><p class="src"><a name="v:snrStartingSequenceNumber" class="def">snrStartingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a> Text</p></div><div class="top"><p class="src"><a name="v:snrEndingSequenceNumber" class="def">snrEndingSequenceNumber</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:sShardId" class="def">sShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> Text</p></div><div class="top"><p class="src"><a name="v:sSequenceNumberRange" class="def">sSequenceNumberRange</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:SequenceNumberRange">SequenceNumberRange</a></p></div><div class="top"><p class="src"><a name="v:sParentShardId" class="def">sParentShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:sHashKeyRange" class="def">sHashKeyRange</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:HashKeyRange">HashKeyRange</a></p></div><div class="top"><p class="src"><a name="v:sAdjacentParentShardId" class="def">sAdjacentParentShardId</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p></div><div class="top"><p class="src"><a name="v:sdStreamStatus" class="def">sdStreamStatus</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamStatus">StreamStatus</a></p></div><div class="top"><p class="src"><a name="v:sdStreamName" class="def">sdStreamName</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> Text</p></div><div class="top"><p class="src"><a name="v:sdStreamARN" class="def">sdStreamARN</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> Text</p></div><div class="top"><p class="src"><a name="v:sdShards" class="def">sdShards</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> [<a href="Network-AWS-Kinesis-V2013_12_02.html#t:Shard">Shard</a>]</p></div><div class="top"><p class="src"><a name="v:sdHasMoreShards" class="def">sdHasMoreShards</a> :: Lens' <a href="Network-AWS-Kinesis-V2013_12_02.html#t:StreamDescription">StreamDescription</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>