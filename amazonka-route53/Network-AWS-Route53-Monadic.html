<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.AWS.Route53.Monadic</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Network-AWS-Route53-Monadic.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">amazonka-route53-0.0.0: Amazon Route 53 SDK</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.AWS.Route53.Monadic</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">ChangeResourceRecordSets</a></li><li><a href="#g:2">ChangeTagsForResource</a></li><li><a href="#g:3">CreateHealthCheck</a></li><li><a href="#g:4">CreateHostedZone</a></li><li><a href="#g:5">DeleteHealthCheck</a></li><li><a href="#g:6">DeleteHostedZone</a></li><li><a href="#g:7">GetChange</a></li><li><a href="#g:8">GetCheckerIpRanges</a></li><li><a href="#g:9">GetGeoLocation</a></li><li><a href="#g:10">GetHealthCheck</a></li><li><a href="#g:11">GetHealthCheckCount</a></li><li><a href="#g:12">GetHostedZone</a></li><li><a href="#g:13">ListGeoLocations</a></li><li><a href="#g:14">ListHealthChecks</a></li><li><a href="#g:15">ListHostedZones</a></li><li><a href="#g:16">ListResourceRecordSets</a></li><li><a href="#g:17">ListTagsForResource</a></li><li><a href="#g:18">ListTagsForResources</a></li><li><a href="#g:19">UpdateHealthCheck</a></li><li><a href="#g:20">Re-exported</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Amazon Route 53 is a scalable Domain Name System (DNS) web service. It
 provides secure and reliable routing to your infrastructure that uses
 Amazon Web Services (AWS) products, such as Amazon Elastic Compute Cloud
 (Amazon EC2), Elastic Load Balancing, or Amazon Simple Storage Service
 (Amazon S3). You can also use Amazon Route 53 to route users to your
 infrastructure outside of AWS.</p><p>This module is provided for convenience. It offers an alternative to the
 common idiom of supplying required fields to an operations's smart constructor,
 using the operation's lenses to modify additional fields, and then sending
 or paginating the request.</p><p>As an example: using <a href="Network-AWS-Route53.html">Network.AWS.Route53</a> with the smart constructor and
 basic lens syntax, before explicitly calling <code>send</code>:</p><pre>import Control.Monad.Trans.AWS
import Network.AWS.Route53

send $ (mkOperationName w x)
     &amp; onLensField1 .~ y
     &amp; onLensField2 .~ z
</pre><p>Versus using <a href="Network-AWS-Route53-Monadic.html">Network.AWS.Route53.Monadic</a> with the <code>State</code> operator variants from
 <a href="Control-Lens-Setter.html">Control.Lens.Setter</a> such as <code><a href="Network-AWS-Route53-Monadic.html#v:.-61-">.=</a></code> to modify any additional request
 parameters before sending:</p><pre>import Network.AWS.Route53.Monadic

operationName w x $ do
    onLensField1 .= y
    onLensField2 .= z
</pre></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:changeResourceRecordSets">changeResourceRecordSets</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; <a href="Network-AWS-Route53-Types.html#t:ChangeBatch">ChangeBatch</a> -&gt; State <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSets">ChangeResourceRecordSets</a> a -&gt; m <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSetsResponse">ChangeResourceRecordSetsResponse</a></li><li class="src short"><a href="#v:changeResourceRecordSetsCatch">changeResourceRecordSetsCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; <a href="Network-AWS-Route53-Types.html#t:ChangeBatch">ChangeBatch</a> -&gt; State <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSets">ChangeResourceRecordSets</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSetsResponse">ChangeResourceRecordSetsResponse</a>)</li><li class="src short"><a href="#v:changeTagsForResource">changeTagsForResource</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; Text -&gt; State <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResource">ChangeTagsForResource</a> a -&gt; m <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResourceResponse">ChangeTagsForResourceResponse</a></li><li class="src short"><a href="#v:changeTagsForResourceCatch">changeTagsForResourceCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; Text -&gt; State <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResource">ChangeTagsForResource</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResourceResponse">ChangeTagsForResourceResponse</a>)</li><li class="src short"><a href="#v:createHealthCheck">createHealthCheck</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; <a href="Network-AWS-Route53-Types.html#t:HealthCheckConfig">HealthCheckConfig</a> -&gt; State <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheck">CreateHealthCheck</a> a -&gt; m <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheckResponse">CreateHealthCheckResponse</a></li><li class="src short"><a href="#v:createHealthCheckCatch">createHealthCheckCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; <a href="Network-AWS-Route53-Types.html#t:HealthCheckConfig">HealthCheckConfig</a> -&gt; State <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheck">CreateHealthCheck</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheckResponse">CreateHealthCheckResponse</a>)</li><li class="src short"><a href="#v:createHostedZone">createHostedZone</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; Text -&gt; State <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZone">CreateHostedZone</a> a -&gt; m <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZoneResponse">CreateHostedZoneResponse</a></li><li class="src short"><a href="#v:createHostedZoneCatch">createHostedZoneCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; Text -&gt; State <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZone">CreateHostedZone</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZoneResponse">CreateHostedZoneResponse</a>)</li><li class="src short"><a href="#v:deleteHealthCheck">deleteHealthCheck</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheck">DeleteHealthCheck</a> a -&gt; m <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheckResponse">DeleteHealthCheckResponse</a></li><li class="src short"><a href="#v:deleteHealthCheckCatch">deleteHealthCheckCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheck">DeleteHealthCheck</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheckResponse">DeleteHealthCheckResponse</a>)</li><li class="src short"><a href="#v:deleteHostedZone">deleteHostedZone</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZone">DeleteHostedZone</a> a -&gt; m <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZoneResponse">DeleteHostedZoneResponse</a></li><li class="src short"><a href="#v:deleteHostedZoneCatch">deleteHostedZoneCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZone">DeleteHostedZone</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZoneResponse">DeleteHostedZoneResponse</a>)</li><li class="src short"><a href="#v:getChange">getChange</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetChange.html#t:GetChange">GetChange</a> a -&gt; m <a href="Network-AWS-Route53-GetChange.html#t:GetChangeResponse">GetChangeResponse</a></li><li class="src short"><a href="#v:getChangeCatch">getChangeCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetChange.html#t:GetChange">GetChange</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetChange.html#t:GetChangeResponse">GetChangeResponse</a>)</li><li class="src short"><a href="#v:getCheckerIpRanges">getCheckerIpRanges</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRanges">GetCheckerIpRanges</a> a -&gt; m <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRangesResponse">GetCheckerIpRangesResponse</a></li><li class="src short"><a href="#v:getCheckerIpRangesCatch">getCheckerIpRangesCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRanges">GetCheckerIpRanges</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRangesResponse">GetCheckerIpRangesResponse</a>)</li><li class="src short"><a href="#v:getGeoLocation">getGeoLocation</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocation">GetGeoLocation</a> a -&gt; m <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocationResponse">GetGeoLocationResponse</a></li><li class="src short"><a href="#v:getGeoLocationCatch">getGeoLocationCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocation">GetGeoLocation</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocationResponse">GetGeoLocationResponse</a>)</li><li class="src short"><a href="#v:getHealthCheck">getHealthCheck</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheck">GetHealthCheck</a> a -&gt; m <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheckResponse">GetHealthCheckResponse</a></li><li class="src short"><a href="#v:getHealthCheckCatch">getHealthCheckCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheck">GetHealthCheck</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheckResponse">GetHealthCheckResponse</a>)</li><li class="src short"><a href="#v:getHealthCheckCount">getHealthCheckCount</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCount">GetHealthCheckCount</a> a -&gt; m <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCountResponse">GetHealthCheckCountResponse</a></li><li class="src short"><a href="#v:getHealthCheckCountCatch">getHealthCheckCountCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCount">GetHealthCheckCount</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCountResponse">GetHealthCheckCountResponse</a>)</li><li class="src short"><a href="#v:getHostedZone">getHostedZone</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZone">GetHostedZone</a> a -&gt; m <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZoneResponse">GetHostedZoneResponse</a></li><li class="src short"><a href="#v:getHostedZoneCatch">getHostedZoneCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZone">GetHostedZone</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZoneResponse">GetHostedZoneResponse</a>)</li><li class="src short"><a href="#v:listGeoLocations">listGeoLocations</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocations">ListGeoLocations</a> a -&gt; m <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocationsResponse">ListGeoLocationsResponse</a></li><li class="src short"><a href="#v:listGeoLocationsCatch">listGeoLocationsCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocations">ListGeoLocations</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocationsResponse">ListGeoLocationsResponse</a>)</li><li class="src short"><a href="#v:listHealthChecks">listHealthChecks</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecks">ListHealthChecks</a> a -&gt; ResumableSource m <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecksResponse">ListHealthChecksResponse</a></li><li class="src short"><a href="#v:listHealthChecksCatch">listHealthChecksCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecks">ListHealthChecks</a> a -&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecksResponse">ListHealthChecksResponse</a>)</li><li class="src short"><a href="#v:listHostedZones">listHostedZones</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZones">ListHostedZones</a> a -&gt; ResumableSource m <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZonesResponse">ListHostedZonesResponse</a></li><li class="src short"><a href="#v:listHostedZonesCatch">listHostedZonesCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZones">ListHostedZones</a> a -&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZonesResponse">ListHostedZonesResponse</a>)</li><li class="src short"><a href="#v:listResourceRecordSets">listResourceRecordSets</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m)) =&gt; Text -&gt; State <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSets">ListResourceRecordSets</a> a -&gt; ResumableSource m <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSetsResponse">ListResourceRecordSetsResponse</a></li><li class="src short"><a href="#v:listResourceRecordSetsCatch">listResourceRecordSetsCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m)) =&gt; Text -&gt; State <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSets">ListResourceRecordSets</a> a -&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSetsResponse">ListResourceRecordSetsResponse</a>)</li><li class="src short"><a href="#v:listTagsForResource">listTagsForResource</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; Text -&gt; State <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResource">ListTagsForResource</a> a -&gt; m <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResourceResponse">ListTagsForResourceResponse</a></li><li class="src short"><a href="#v:listTagsForResourceCatch">listTagsForResourceCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; Text -&gt; State <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResource">ListTagsForResource</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResourceResponse">ListTagsForResourceResponse</a>)</li><li class="src short"><a href="#v:listTagsForResources">listTagsForResources</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; List1 Text -&gt; State <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResources">ListTagsForResources</a> a -&gt; m <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResourcesResponse">ListTagsForResourcesResponse</a></li><li class="src short"><a href="#v:listTagsForResourcesCatch">listTagsForResourcesCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a> -&gt; List1 Text -&gt; State <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResources">ListTagsForResources</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResourcesResponse">ListTagsForResourcesResponse</a>)</li><li class="src short"><a href="#v:updateHealthCheck">updateHealthCheck</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheck">UpdateHealthCheck</a> a -&gt; m <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheckResponse">UpdateHealthCheckResponse</a></li><li class="src short"><a href="#v:updateHealthCheckCatch">updateHealthCheckCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; Text -&gt; State <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheck">UpdateHealthCheck</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheckResponse">UpdateHealthCheckResponse</a>)</li><li class="src short">module <a href="Network-AWS-Route53.html">Network.AWS.Route53</a></li><li class="src short"><a href="#v:.-61-">(.=)</a> :: MonadState s m =&gt; ASetter s s a b -&gt; b -&gt; m ()</li><li class="src short"><a href="#v:-63--61-">(?=)</a> :: MonadState s m =&gt; ASetter s s a (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> b) -&gt; b -&gt; m ()</li><li class="src short"><a href="#v:-60--62--61-">(&lt;&gt;=)</a> :: (MonadState s m, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> a) =&gt; ASetter' s a -&gt; a -&gt; m ()</li><li class="src short"><a href="#v:-37--61-">(%=)</a> :: (Profunctor p, MonadState s m) =&gt; Setting p s s a b -&gt; p a b -&gt; m ()</li></ul></div><div id="interface"><h1 id="g:1">ChangeResourceRecordSets</h1><div class="doc"><p>Use this action to create or change your authoritative DNS information. To
 use this action, send a POST request to the 2013-04-01<em>hostedzone</em>hosted
 Zone ID/rrset resource. The request body must include an XML document with
 a ChangeResourceRecordSetsRequest element. Changes are a list of change
 items and are considered transactional. For more information on
 transactional changes, also known as change batches, see Creating,
 Changing, and Deleting Resource Record Sets Using the Route 53 API in the
 Amazon Route 53 Developer Guide. Due to the nature of transactional
 changes, you cannot delete the same resource record set more than once in a
 single change batch. If you attempt to delete the same change batch more
 than once, Route 53 returns an InvalidChangeBatch error. In response to a
 ChangeResourceRecordSets request, your DNS data is changed on all Route 53
 DNS servers. Initially, the status of a change is PENDING. This means the
 change has not yet propagated to all the authoritative Route 53 DNS
 servers. When the change is propagated to all hosts, the change returns a
 status of INSYNC. Note the following limitations on a
 ChangeResourceRecordSets request: - A request cannot contain more than 100
 Change elements. - A request cannot contain more than 1000 ResourceRecord
 elements. The sum of the number of characters (including spaces) in all
 Value elements in a request cannot exceed 32,000 characters.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:changeResourceRecordSets" class="def">changeResourceRecordSets</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeResourceRecordSets.html#v:crrsHostedZoneId">crrsHostedZoneId</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Route53-Types.html#t:ChangeBatch">ChangeBatch</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeResourceRecordSets.html#v:crrsChangeBatch">crrsChangeBatch</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSets">ChangeResourceRecordSets</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSetsResponse">ChangeResourceRecordSetsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:changeResourceRecordSetsCatch" class="def">changeResourceRecordSetsCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeResourceRecordSets.html#v:crrsHostedZoneId">crrsHostedZoneId</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Route53-Types.html#t:ChangeBatch">ChangeBatch</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeResourceRecordSets.html#v:crrsChangeBatch">crrsChangeBatch</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSets">ChangeResourceRecordSets</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ChangeResourceRecordSets.html#t:ChangeResourceRecordSetsResponse">ChangeResourceRecordSetsResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:2">ChangeTagsForResource</h1><div class="doc"><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:changeTagsForResource" class="def">changeTagsForResource</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeTagsForResource.html#v:ctfrResourceType">ctfrResourceType</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeTagsForResource.html#v:ctfrResourceId">ctfrResourceId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResource">ChangeTagsForResource</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResourceResponse">ChangeTagsForResourceResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:changeTagsForResourceCatch" class="def">changeTagsForResourceCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeTagsForResource.html#v:ctfrResourceType">ctfrResourceType</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ChangeTagsForResource.html#v:ctfrResourceId">ctfrResourceId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResource">ChangeTagsForResource</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ChangeTagsForResource.html#t:ChangeTagsForResourceResponse">ChangeTagsForResourceResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:3">CreateHealthCheck</h1><div class="doc"><p>This action creates a new health check. To create a new health check, send
 a POST request to the 2013-04-01/healthcheck resource. The request body
 must include an XML document with a CreateHealthCheckRequest element. The
 response returns the CreateHealthCheckResponse element that contains
 metadata about the health check.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:createHealthCheck" class="def">createHealthCheck</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHealthCheck.html#v:chcCallerReference">chcCallerReference</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Route53-Types.html#t:HealthCheckConfig">HealthCheckConfig</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHealthCheck.html#v:chcHealthCheckConfig">chcHealthCheckConfig</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheck">CreateHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheckResponse">CreateHealthCheckResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:createHealthCheckCatch" class="def">createHealthCheckCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHealthCheck.html#v:chcCallerReference">chcCallerReference</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-Route53-Types.html#t:HealthCheckConfig">HealthCheckConfig</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHealthCheck.html#v:chcHealthCheckConfig">chcHealthCheckConfig</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheck">CreateHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-CreateHealthCheck.html#t:CreateHealthCheckResponse">CreateHealthCheckResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:4">CreateHostedZone</h1><div class="doc"><p>This action creates a new hosted zone. To create a new hosted zone, send a
 POST request to the 2013-04-01/hostedzone resource. The request body must
 include an XML document with a CreateHostedZoneRequest element. The
 response returns the CreateHostedZoneResponse element that contains
 metadata about the hosted zone. Route 53 automatically creates a default
 SOA record and four NS records for the zone. The NS records in the hosted
 zone are the name servers you give your registrar to delegate your domain
 to. For more information about SOA and NS records, see NS and SOA Records
 that Route 53 Creates for a Hosted Zone in the Amazon Route 53 Developer
 Guide. When you create a zone, its initial status is PENDING. This means
 that it is not yet available on all DNS servers. The status of the zone
 changes to INSYNC when the NS and SOA records are available on all Route 53
 DNS servers.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:createHostedZone" class="def">createHostedZone</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHostedZone.html#v:chzName">chzName</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHostedZone.html#v:chzCallerReference">chzCallerReference</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZone">CreateHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZoneResponse">CreateHostedZoneResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:createHostedZoneCatch" class="def">createHostedZoneCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHostedZone.html#v:chzName">chzName</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-CreateHostedZone.html#v:chzCallerReference">chzCallerReference</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZone">CreateHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-CreateHostedZone.html#t:CreateHostedZoneResponse">CreateHostedZoneResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:5">DeleteHealthCheck</h1><div class="doc"><p>This action deletes a health check. To delete a health check, send a DELETE
 request to the 2013-04-01<em>healthcheck</em>health check ID resource. You can
 delete a health check only if there are no resource record sets associated
 with this health check. If resource record sets are associated with this
 health check, you must disassociate them before you can delete your health
 check. If you try to delete a health check that is associated with resource
 record sets, Route 53 will deny your request with a HealthCheckInUse error.
 For information about disassociating the records from your health check,
 see ChangeResourceRecordSets.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:deleteHealthCheck" class="def">deleteHealthCheck</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-DeleteHealthCheck.html#v:dhcHealthCheckId">dhcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheck">DeleteHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheckResponse">DeleteHealthCheckResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:deleteHealthCheckCatch" class="def">deleteHealthCheckCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-DeleteHealthCheck.html#v:dhcHealthCheckId">dhcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheck">DeleteHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-DeleteHealthCheck.html#t:DeleteHealthCheckResponse">DeleteHealthCheckResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:6">DeleteHostedZone</h1><div class="doc"><p>This action deletes a hosted zone. To delete a hosted zone, send a DELETE
 request to the 2013-04-01<em>hostedzone</em>hosted zone ID resource. For more
 information about deleting a hosted zone, see Deleting a Hosted Zone in the
 Amazon Route 53 Developer Guide. You can delete a hosted zone only if there
 are no resource record sets other than the default SOA record and NS
 resource record sets. If your hosted zone contains other resource record
 sets, you must delete them before you can delete your hosted zone. If you
 try to delete a hosted zone that contains other resource record sets, Route
 53 will deny your request with a HostedZoneNotEmpty error. For information
 about deleting records from your hosted zone, see ChangeResourceRecordSets.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:deleteHostedZone" class="def">deleteHostedZone</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-DeleteHostedZone.html#v:dhzId">dhzId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZone">DeleteHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZoneResponse">DeleteHostedZoneResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:deleteHostedZoneCatch" class="def">deleteHostedZoneCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-DeleteHostedZone.html#v:dhzId">dhzId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZone">DeleteHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-DeleteHostedZone.html#t:DeleteHostedZoneResponse">DeleteHostedZoneResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:7">GetChange</h1><div class="doc"><p>This action returns the current status of a change batch request. The
 status is one of the following values: - PENDING indicates that the changes
 in this request have not replicated to all Route 53 DNS servers. This is
 the initial status of all change batch requests. - INSYNC indicates that
 the changes have replicated to all Amazon Route 53 DNS servers.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getChange" class="def">getChange</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetChange.html#v:gcId">gcId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetChange.html#t:GetChange">GetChange</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-GetChange.html#t:GetChangeResponse">GetChangeResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:getChangeCatch" class="def">getChangeCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetChange.html#v:gcId">gcId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetChange.html#t:GetChange">GetChange</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetChange.html#t:GetChangeResponse">GetChangeResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:8">GetCheckerIpRanges</h1><div class="doc"><p>To retrieve a list of the IP ranges used by Amazon Route 53 health checkers
 to check the health of your resources, send a GET request to the
 2013-04-01/checkeripranges resource. You can use these IP addresses to
 configure router and firewall rules to allow health checkers to check the
 health of your resources.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getCheckerIpRanges" class="def">getCheckerIpRanges</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRanges">GetCheckerIpRanges</a> a -&gt; m <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRangesResponse">GetCheckerIpRangesResponse</a></p></div><div class="top"><p class="src"><a name="v:getCheckerIpRangesCatch" class="def">getCheckerIpRangesCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRanges">GetCheckerIpRanges</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetCheckerIpRanges.html#t:GetCheckerIpRangesResponse">GetCheckerIpRangesResponse</a>)</p></div><h1 id="g:9">GetGeoLocation</h1><div class="doc"><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getGeoLocation" class="def">getGeoLocation</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocation">GetGeoLocation</a> a -&gt; m <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocationResponse">GetGeoLocationResponse</a></p></div><div class="top"><p class="src"><a name="v:getGeoLocationCatch" class="def">getGeoLocationCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocation">GetGeoLocation</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetGeoLocation.html#t:GetGeoLocationResponse">GetGeoLocationResponse</a>)</p></div><h1 id="g:10">GetHealthCheck</h1><div class="doc"><p>To retrieve the health check, send a GET request to the
 2013-04-01<em>healthcheck</em>health check ID resource.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getHealthCheck" class="def">getHealthCheck</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetHealthCheck.html#v:ghcHealthCheckId">ghcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheck">GetHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheckResponse">GetHealthCheckResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:getHealthCheckCatch" class="def">getHealthCheckCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetHealthCheck.html#v:ghcHealthCheckId">ghcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheck">GetHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHealthCheck.html#t:GetHealthCheckResponse">GetHealthCheckResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:11">GetHealthCheckCount</h1><div class="doc"><p>To retrieve a count of all your health checks, send a GET request to the
 2013-04-01/healthcheckcount resource.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getHealthCheckCount" class="def">getHealthCheckCount</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCount">GetHealthCheckCount</a> a -&gt; m <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCountResponse">GetHealthCheckCountResponse</a></p></div><div class="top"><p class="src"><a name="v:getHealthCheckCountCatch" class="def">getHealthCheckCountCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCount">GetHealthCheckCount</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHealthCheckCount.html#t:GetHealthCheckCountResponse">GetHealthCheckCountResponse</a>)</p></div><h1 id="g:12">GetHostedZone</h1><div class="doc"><p>To retrieve the delegation set for a hosted zone, send a GET request to the
 2013-04-01<em>hostedzone</em>hosted zone ID resource. The delegation set is the
 four Route 53 name servers that were assigned to the hosted zone when you
 created it.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:getHostedZone" class="def">getHostedZone</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetHostedZone.html#v:ghzId">ghzId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZone">GetHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZoneResponse">GetHostedZoneResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:getHostedZoneCatch" class="def">getHostedZoneCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-GetHostedZone.html#v:ghzId">ghzId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZone">GetHostedZone</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-GetHostedZone.html#t:GetHostedZoneResponse">GetHostedZoneResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:13">ListGeoLocations</h1><div class="doc"><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listGeoLocations" class="def">listGeoLocations</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocations">ListGeoLocations</a> a -&gt; m <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocationsResponse">ListGeoLocationsResponse</a></p></div><div class="top"><p class="src"><a name="v:listGeoLocationsCatch" class="def">listGeoLocationsCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env m) =&gt; State <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocations">ListGeoLocations</a> a -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListGeoLocations.html#t:ListGeoLocationsResponse">ListGeoLocationsResponse</a>)</p></div><h1 id="g:14">ListHealthChecks</h1><div class="doc"><p>To retrieve a list of your health checks, send a GET request to the
 2013-04-01/healthcheck resource. The response to this request includes a
 HealthChecks element with zero, one, or multiple HealthCheck child
 elements. By default, the list of health checks is displayed on a single
 page. You can control the length of the page that is displayed by using the
 MaxItems parameter. You can use the Marker parameter to control the health
 check that the list begins with. Amazon Route 53 returns a maximum of 100
 items. If you set MaxItems to a value greater than 100, Amazon Route 53
 returns only the first 100.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listHealthChecks" class="def">listHealthChecks</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecks">ListHealthChecks</a> a -&gt; ResumableSource m <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecksResponse">ListHealthChecksResponse</a></p></div><div class="top"><p class="src"><a name="v:listHealthChecksCatch" class="def">listHealthChecksCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecks">ListHealthChecks</a> a -&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListHealthChecks.html#t:ListHealthChecksResponse">ListHealthChecksResponse</a>)</p></div><h1 id="g:15">ListHostedZones</h1><div class="doc"><p>To retrieve a list of your hosted zones, send a GET request to the
 2013-04-01/hostedzone resource. The response to this request includes a
 HostedZones element with zero, one, or multiple HostedZone child elements.
 By default, the list of hosted zones is displayed on a single page. You can
 control the length of the page that is displayed by using the MaxItems
 parameter. You can use the Marker parameter to control the hosted zone that
 the list begins with. Amazon Route 53 returns a maximum of 100 items. If
 you set MaxItems to a value greater than 100, Amazon Route 53 returns only
 the first 100.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listHostedZones" class="def">listHostedZones</a> :: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZones">ListHostedZones</a> a -&gt; ResumableSource m <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZonesResponse">ListHostedZonesResponse</a></p></div><div class="top"><p class="src"><a name="v:listHostedZonesCatch" class="def">listHostedZonesCatch</a> :: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m)) =&gt; State <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZones">ListHostedZones</a> a -&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListHostedZones.html#t:ListHostedZonesResponse">ListHostedZonesResponse</a>)</p></div><h1 id="g:16">ListResourceRecordSets</h1><div class="doc"><p>Imagine all the resource record sets in a zone listed out in front of you.
 Imagine them sorted lexicographically first by DNS name (with the labels
 reversed, like &quot;com.amazon.www&quot; for example), and secondarily,
 lexicographically by record type. This operation retrieves at most MaxItems
 resource record sets from this list, in order, starting at a position
 specified by the Name and Type arguments: If both Name and Type are
 omitted, this means start the results at the first RRSET in the HostedZone.
 If Name is specified but Type is omitted, this means start the results at
 the first RRSET in the list whose name is greater than or equal to Name. If
 both Name and Type are specified, this means start the results at the first
 RRSET in the list whose name is greater than or equal to Name and whose
 type is greater than or equal to Type. It is an error to specify the Type
 but not the Name. Use ListResourceRecordSets to retrieve a single known
 record set by specifying the record set's name and type, and setting
 MaxItems = 1 To retrieve all the records in a HostedZone, first pause any
 processes making calls to ChangeResourceRecordSets. Initially call
 ListResourceRecordSets without a Name and Type to get the first page of
 record sets. For subsequent calls, set Name and Type to the NextName and
 NextType values returned by the previous response. In the presence of
 concurrent ChangeResourceRecordSets calls, there is no consistency of
 results across calls to ListResourceRecordSets. The only way to get a
 consistent multi-page snapshot of all RRSETs in a zone is to stop making
 changes while pagination is in progress. However, the results from
 ListResourceRecordSets are consistent within a page. If MakeChange calls
 are taking place concurrently, the result of each one will either be
 completely visible in your results or not at all. You will not see partial
 changes, or changes that do not ultimately succeed. (This follows from the
 fact that MakeChange is atomic) The results from ListResourceRecordSets are
 strongly consistent with ChangeResourceRecordSets. To be precise, if a
 single process makes a call to ChangeResourceRecordSets and receives a
 successful response, the effects of that change will be visible in a
 subsequent call to ListResourceRecordSets by that process.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listResourceRecordSets" class="def">listResourceRecordSets</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env (ResumableSource m))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListResourceRecordSets.html#v:lrrsHostedZoneId">lrrsHostedZoneId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSets">ListResourceRecordSets</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; ResumableSource m <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSetsResponse">ListResourceRecordSetsResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:listResourceRecordSetsCatch" class="def">listResourceRecordSetsCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env (ResumableSource m))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListResourceRecordSets.html#v:lrrsHostedZoneId">lrrsHostedZoneId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSets">ListResourceRecordSets</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; ResumableSource m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListResourceRecordSets.html#t:ListResourceRecordSetsResponse">ListResourceRecordSetsResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:17">ListTagsForResource</h1><div class="doc"><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listTagsForResource" class="def">listTagsForResource</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResource.html#v:ltfrResourceType">ltfrResourceType</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResource.html#v:ltfrResourceId">ltfrResourceId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResource">ListTagsForResource</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResourceResponse">ListTagsForResourceResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:listTagsForResourceCatch" class="def">listTagsForResourceCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResource.html#v:ltfrResourceType">ltfrResourceType</a></code></p></td></tr><tr><td class="src">-&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResource.html#v:ltfrResourceId">ltfrResourceId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResource">ListTagsForResource</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListTagsForResource.html#t:ListTagsForResourceResponse">ListTagsForResourceResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:18">ListTagsForResources</h1><div class="doc"><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:listTagsForResources" class="def">listTagsForResources</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResources.html#v:ltfr1ResourceType">ltfr1ResourceType</a></code></p></td></tr><tr><td class="src">-&gt; List1 Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResources.html#v:ltfr1ResourceIds">ltfr1ResourceIds</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResources">ListTagsForResources</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResourcesResponse">ListTagsForResourcesResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:listTagsForResourcesCatch" class="def">listTagsForResourcesCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Network-AWS-Route53-Types.html#t:TagResourceType">TagResourceType</a></td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResources.html#v:ltfr1ResourceType">ltfr1ResourceType</a></code></p></td></tr><tr><td class="src">-&gt; List1 Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-ListTagsForResources.html#v:ltfr1ResourceIds">ltfr1ResourceIds</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResources">ListTagsForResources</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-ListTagsForResources.html#t:ListTagsForResourcesResponse">ListTagsForResourcesResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:19">UpdateHealthCheck</h1><div class="doc"><p>This action updates an existing health check. To update a health check,
 send a POST request to the 2013-05-27<em>healthcheck</em>health check ID resource.
 The request body must include an XML document with an
 UpdateHealthCheckRequest element. The response returns an
 UpdateHealthCheckResponse element, which contains metadata about the health
 check.</p><p>See: <code><a href="Network-AWS.html#t:Route53">Route53</a></code></p></div><div class="top"><p class="src"><a name="v:updateHealthCheck" class="def">updateHealthCheck</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadError Error m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-UpdateHealthCheck.html#v:uhcHealthCheckId">uhcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheck">UpdateHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheckResponse">UpdateHealthCheckResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:updateHealthCheckCatch" class="def">updateHealthCheckCatch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (MonadCatch m, MonadResource m, MonadReader Env m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Text</td><td class="doc"><p><code><a href="Network-AWS-Route53-UpdateHealthCheck.html#v:uhcHealthCheckId">uhcHealthCheckId</a></code></p></td></tr><tr><td class="src">-&gt; State <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheck">UpdateHealthCheck</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Either.html#t:Either">Either</a> ServiceEr <a href="Network-AWS-Route53-UpdateHealthCheck.html#t:UpdateHealthCheckResponse">UpdateHealthCheckResponse</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:20">Re-exported</h1><div class="top"><p class="src">module <a href="Network-AWS-Route53.html">Network.AWS.Route53</a></p></div><div class="top"><p class="src"><a name="v:.-61-" class="def">(.=)</a> :: MonadState s m =&gt; ASetter s s a b -&gt; b -&gt; m ()</p></div><div class="top"><p class="src"><a name="v:-63--61-" class="def">(?=)</a> :: MonadState s m =&gt; ASetter s s a (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> b) -&gt; b -&gt; m ()</p></div><div class="top"><p class="src"><a name="v:-60--62--61-" class="def">(&lt;&gt;=)</a> :: (MonadState s m, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> a) =&gt; ASetter' s a -&gt; a -&gt; m ()</p></div><div class="top"><p class="src"><a name="v:-37--61-" class="def">(%=)</a> :: (Profunctor p, MonadState s m) =&gt; Setting p s s a b -&gt; p a b -&gt; m ()</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>